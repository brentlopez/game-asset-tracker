# Game Asset Tracking System - Architecture

## Overview

The Game Asset Tracking System is a hybrid solution for managing game development assets at scale. It combines the flexibility of Obsidian for high-level organization with the power of SQLite for granular, searchable metadata across thousands of individual asset files.

## System Components

### 1. Ingestion Scripts (Python)
- **Location:** `ingestion/`
- **Purpose:** Scan local NAS or folder structures and generate standardized JSON manifests
- **Language:** Python 3.x
- **Output:** JSON files conforming to the strict schema (see Data Model section)

### 2. Obsidian Plugin (TypeScript/React)
- **Location:** `obsidian-plugin/`
- **Purpose:** 
  - Read JSON manifests generated by ingestion scripts
  - Update SQLite database with file-level asset metadata
  - Create/update Markdown notes for Asset Packs in Obsidian vault
- **Language:** TypeScript with React for UI components
- **Database:** SQLite (embedded)

### 3. Schemas (Reference)
- **Location:** `schemas/`
- **Purpose:** Store reference schemas, documentation, and examples

## The Workflow

```
┌─────────────────────────────────────────────────────────────────┐
│                         WORKFLOW                                 │
└─────────────────────────────────────────────────────────────────┘

1. USER triggers ingestion script
   ↓
2. Python Script scans NAS/folder
   ↓
3. Script generates JSON manifest (conforms to strict schema)
   ↓
4. JSON file saved to output directory
   ↓
5. User imports JSON via Obsidian Plugin
   ↓
6. Plugin reads JSON manifest
   ↓
7. Plugin performs TWO actions simultaneously:
   │
   ├─→ A. Updates SQLite Index
   │      - Inserts/updates rows for each asset file
   │      - Enables fast, granular search across thousands of files
   │
   └─→ B. Creates/Updates Markdown Note for Asset Pack
          - Creates new note in Obsidian vault
          - Includes pack metadata, tags, license info
          - Links to relevant projects via Obsidian wikilinks
```

### Key Workflow Principles

- **JSON as the Source of Truth:** All data flows through the standardized JSON schema
- **Dual Output:** Plugin maintains both the SQLite index (for search) and Markdown notes (for human organization)
- **Obsidian-First Navigation:** Users browse Asset Packs in Obsidian, search individual files via plugin interface
- **One-Way Sync:** Ingestion scripts → JSON → Plugin → Database + Markdown (no reverse sync)

## The Data Model

### Asset Pack (Obsidian Markdown Note)

An **Asset Pack** represents a collection of related assets from a single source. It is materialized as:
- A **Markdown note** in the Obsidian vault
- Contains high-level metadata, tags, and links to projects
- Human-readable and editable

**Example Note Structure:**
```markdown
---
pack_id: uuid-string
source: Unity Asset Store
license_link: https://example.com/license
tags: [3d-models, characters, fantasy]
---

# Dragon Character Pack

Root Path: `/Volumes/NAS/Assets/Unity/DragonPack`

## Description
High-quality dragon character models with animations and textures.

## Related Projects
- [[Game Project Alpha]]
- [[Prototype Demo]]

## Assets
Total Files: 1,247
- 3D Models: 15
- Textures: 980
- Animations: 150
- Audio: 102
```

### Asset File (SQLite Database Row)

An **Asset File** represents an individual file within an Asset Pack. It is stored as:
- A **row in the SQLite database**
- Optimized for fast search and filtering
- Contains granular metadata (file type, size, relative path, tags)

**SQLite Schema:**
```sql
CREATE TABLE assets (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    pack_id TEXT NOT NULL,
    relative_path TEXT NOT NULL,
    file_type TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    metadata_json TEXT,  -- JSON blob for flexible metadata
    local_tags TEXT,     -- Comma-separated or JSON array
    FOREIGN KEY (pack_id) REFERENCES packs(pack_id)
);

CREATE TABLE packs (
    pack_id TEXT PRIMARY KEY,
    pack_name TEXT NOT NULL,
    root_path TEXT NOT NULL,
    source TEXT,
    license_link TEXT,
    global_tags TEXT,  -- Comma-separated or JSON array
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_file_type ON assets(file_type);
CREATE INDEX idx_pack_id ON assets(pack_id);
CREATE INDEX idx_local_tags ON assets(local_tags);
```

## The Strict JSON Schema

**All ingestion scripts MUST generate JSON that validates against `schemas/manifest.schema.json`.**

The formal JSON Schema (Draft 7) definition is located at `schemas/manifest.schema.json`. This schema enforces strict validation rules including:
- UUID format for `pack_id`
- Required vs. optional fields
- Type constraints and string patterns
- Array uniqueness for tags
- No additional properties allowed

Refer to `schemas/README.md` for validation examples in Python and TypeScript.

### Schema Definition (Reference)

```json
{
  "pack_id": "UUID (string)",
  "pack_name": "Name of the pack (string)",
  "root_path": "Absolute path to the pack on disk (string)",
  "source": "E.g. Unity, Epic, NAS (string)",
  "license_link": "URL or path to license (string)",
  "global_tags": ["Array", "of", "Strings"],
  "assets": [
    {
      "relative_path": "Path relative to root_path (string)",
      "file_type": "extension (e.g. wav, png)",
      "size_bytes": 1024,
      "metadata": { "duration": "optional string", "dimensions": "optional string" },
      "local_tags": ["Array", "of", "strings", "derived", "from", "folder", "names"]
    }
  ]
}
```

### Field Descriptions

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `pack_id` | string (UUID) | Yes | Unique identifier for the asset pack |
| `pack_name` | string | Yes | Human-readable name of the pack |
| `root_path` | string | Yes | Absolute path to the pack's root directory on disk |
| `source` | string | Yes | Origin of the pack (e.g., "Unity Asset Store", "Epic Marketplace", "NAS") |
| `license_link` | string | No | URL or file path to license documentation |
| `global_tags` | array[string] | No | Tags applicable to entire pack (e.g., ["3d", "fantasy", "characters"]) |
| `assets` | array[object] | Yes | Array of individual asset files |
| `assets[].relative_path` | string | Yes | Path relative to `root_path` |
| `assets[].file_type` | string | Yes | File extension (e.g., "png", "wav", "fbx") |
| `assets[].size_bytes` | integer | Yes | File size in bytes |
| `assets[].metadata` | object | No | Flexible key-value pairs for file-specific metadata |
| `assets[].local_tags` | array[string] | No | Tags derived from folder names or manual annotation |

### Example JSON

```json
{
  "pack_id": "550e8400-e29b-41d4-a716-446655440000",
  "pack_name": "Dragon Character Pack",
  "root_path": "/Volumes/NAS/Assets/Unity/DragonPack",
  "source": "Unity Asset Store",
  "license_link": "https://assetstore.unity.com/license",
  "global_tags": ["3d-models", "characters", "fantasy", "dragons"],
  "assets": [
    {
      "relative_path": "Models/Dragon_Red.fbx",
      "file_type": "fbx",
      "size_bytes": 4567890,
      "metadata": {
        "poly_count": "15000",
        "rigged": "true"
      },
      "local_tags": ["models", "red-dragon"]
    },
    {
      "relative_path": "Textures/DragonSkin_Diffuse.png",
      "file_type": "png",
      "size_bytes": 2048000,
      "metadata": {
        "dimensions": "2048x2048",
        "format": "RGBA"
      },
      "local_tags": ["textures", "diffuse"]
    },
    {
      "relative_path": "Audio/DragonRoar.wav",
      "file_type": "wav",
      "size_bytes": 1234567,
      "metadata": {
        "duration": "3.5s",
        "sample_rate": "44100"
      },
      "local_tags": ["audio", "sfx"]
    }
  ]
}
```

## Implementation Guidelines

### For Ingestion Script Developers

1. **Scan the target directory recursively**
2. **Generate unique UUID for each pack** (lowercase, hyphenated format)
3. **Collect file metadata:**
   - Relative paths from pack root
   - File extensions (normalize to lowercase, e.g., `.PNG` → `png`)
   - File sizes in bytes
   - Any format-specific metadata (duration, dimensions, etc.) as string values
4. **Derive tags from folder structure** (e.g., folder "Audio/SFX" → tags: ["audio", "sfx"])
5. **Generate JSON matching the structure in `schemas/manifest.schema.json`**
6. **VALIDATE the generated JSON** against `schemas/manifest.schema.json` using `jsonschema` library
7. **Only save valid JSON** to the designated output directory
8. **Log validation errors** if manifest generation fails

### For Obsidian Plugin Developers

1. **Provide JSON import UI** (file picker or drag-and-drop)
2. **Load and validate JSON:**
   - Read the manifest file
   - Validate against `schemas/manifest.schema.json` using AJV library
   - If validation fails: display errors to user and halt import
   - If validation succeeds: proceed to step 3
3. **Parse validated JSON and extract:**
   - Pack-level metadata for Markdown note
   - Asset-level data for SQLite insertion
4. **Create/update SQLite tables:**
   - Insert pack metadata into `packs` table (or update if pack_id exists)
   - Batch insert assets into `assets` table
   - Use transactions for atomicity
5. **Generate Markdown note:**
   - Use pack_id or sanitized pack_name as filename
   - Include frontmatter with pack metadata
   - Format note with summary statistics and asset counts
   - Save to vault's designated asset packs folder
6. **Provide search interface:**
   - Query SQLite for file-level searches (by type, tags, path)
   - Display results with links to parent Asset Pack notes
   - Support filtering by multiple criteria

### For Users

1. **Run ingestion script** on your asset directories
2. **Import generated JSON** via Obsidian plugin
3. **Browse Asset Packs** as Markdown notes in Obsidian
4. **Search individual files** using plugin's search interface
5. **Link Asset Packs to your projects** using Obsidian wikilinks

## Technology Stack

| Component | Technology | Purpose |
|-----------|-----------|---------|
| Ingestion Scripts | Python 3.x | File scanning, metadata extraction, JSON generation |
| Obsidian Plugin | TypeScript, React | UI, JSON parsing, database operations, note generation |
| Database | SQLite | Fast, embedded search index for asset files |
| Data Format | JSON | Portable, human-readable interchange format |
| Notes | Markdown | Human-readable, version-controllable, Obsidian-native |

## Design Decisions

### Why Hybrid (Obsidian + SQLite)?

- **Obsidian strengths:** Visual organization, linking, human-readable notes, backlinks
- **SQLite strengths:** Fast search across thousands of rows, structured queries, scalability
- **Hybrid approach:** Get the best of both worlds

### Why JSON as Intermediate Format?

- **Portability:** Scripts can run offline, JSON files are transferable
- **Debugging:** Easy to inspect and validate manually
- **Decoupling:** Scripts and plugin can evolve independently
- **Version Control:** JSON files can be committed to git for auditing

### Why One-Way Sync?

- **Simplicity:** No conflict resolution needed
- **Source of Truth:** Filesystem is the ultimate source
- **Re-ingestable:** Can regenerate JSON and re-import anytime

## Future Enhancements

- **Web-based Viewer:** Browse assets without Obsidian
- **Asset Previews:** Thumbnail generation for images/models
- **Dependency Tracking:** Link assets that reference each other
- **Usage Analytics:** Track which assets are used in which projects
- **Batch Operations:** Tag, move, or archive multiple assets
- **Cloud Storage Integration:** Support for S3, Google Drive, etc.

## File Structure Reference

```
game-asset-tracker/
├── ARCHITECTURE.md          # This file (source of truth)
├── README.md                # Project overview and getting started
├── .gitignore               # Git ignore patterns
│
├── ingestion-scripts/       # Python scripts for scanning assets
│   ├── README.md
│   ├── requirements.txt
│   └── ingest.py           # Main ingestion script (to be developed)
│
├── obsidian-plugin/        # TypeScript plugin for Obsidian
│   ├── README.md
│   ├── package.json
│   ├── manifest.json
│   ├── src/
│   │   ├── main.ts
│   │   ├── database.ts
│   │   └── ui/
│   └── tsconfig.json
│
├── schemas/                # Reference schemas and examples
    ├── README.md           # Schema documentation and validation guide
    ├── manifest.schema.json # Formal JSON Schema (Draft 7) - THE CONTRACT
    └── example-manifest.json # Valid example manifest
```

## Getting Started

See `README.md` for setup instructions and quick start guide.
